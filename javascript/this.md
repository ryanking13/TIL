# this

> 2018/02/02

타 객체지향 언어에서 `this` 키워드는 주로 특정 클래스 인스턴스 내에서 해당 인스턴스를 가리키는 역할을 한다.

그러나 자바스크립트에서는 조금 더 고차원적인 의미를 가지는데, 함수가 어떠한 문맥에서 실행되었는지, 즉 함수를 어떻게 실행하느냐가 `this`를 정한다.

```js

function a(){
  console.log(this);
}

a();

// Window { ... } - browser
// global { ... } - Node.js
```

그냥 함수를 실행하는 경우에서 `this`는 전역 객체가 된다.

브라우저에서는 window 객체, node 에서는 global 객체가 된다.

```js
b = [1, 2];
b.foo = a;
b.foo();

// [ 1, 2, foo: [Function: a] ]
```

한편, 동일한 함수를 메서드로 만들어 실행하면 `this`는 해당 메소드를 가진 객체가 된다.

```js
var c = b.foo;
c();

// window { ... }
```

이 때 중요한 것은 함수가 처음에 함수로 선언되었는가, 메소드로 선언되었는가가 중요한 것이 아니라, 실행하는 시점에서 어떻게 실행되는가가 `this`를 결정한다는 것이다.

자바스크립트에서는 함수가 일급 객체로 변수처럼 다루어지기에 메소드를 변수에 할당하여 실행하는 일이 흔히 있는데, 이런 차이를 이해해야 할 필요가 있다.

문제를 발생시키지 않으려면 `call()`, `apply()`를 사용하는 방법이 있다.

`call()` `apply()`의 첫 인자로 `this`를 결정하여 줌으로써, 함수의 실행 컨텍스트에 따라서 `this`가 바뀌는 부작용을 피할 수 있다.

---

### Reference

> 함수형 자바스크립트 프로그래밍 - 유인동 저
